<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
<head>

<style type="text/css">
  div.chunk {
    margin: 0em 0.5em;
  }
  pre {
    margin: 0em 0em;
  }

</style>

<title>Appendix A - Full source</title></head><body><div class="section"><h1>Appendix A - Full source</h1><p><div class="chunk"><pre>
forth-wordlist wordlist dup set-current 2 set-order



: assert ( n -- )
    0= if abort then ;


: linked-list
    create 0 , 0 , ;

: allocate' ( n -- a )
    allocate 0= assert ;

: zero ( a n -- )
    0 fill ;
: allocate0 ( n -- a )
    dup allocate' swap 2dup zero drop ;

: chain-new ( n -- a )
    1+ cells allocate0 ;
: chain-fillout ( .. a n -- a )
    0 do dup i 1+ cells + swap &gt;r ! r&gt; loop ;
: chain-link ( ..n -- a )
    dup chain-new swap chain-fillout ;
: chain-first ( ..n head[t] -- )
    &gt;r chain-link r&gt; 2dup ! cell+ ! ;
: chain-rest ( ..n head[t] -- )
    &gt;r chain-link r&gt; 2dup cell+ @ ! cell+ ! ;
: chain ( ..n head[t] -- )
    dup @ if chain-rest else chain-first then ;

: -&gt;next ( a -- a' ) @ ;

: $clone ( $ - $ )
    dup allocate 0= assert swap 2dup &gt;r &gt;r move r&gt; r&gt; ;

: 3dup ( xyz -- xyzxyz )
    dup 2over rot ;


: atom-length@ ( A -- n )
    1 cells + @ ;
: atom-data@ ( A -- a )
    2 cells + @ ;
: atom-string@ ( A -- $ )
    dup atom-data@ swap atom-length@ ;
: atom-meaning-head ( A -- A[head] )
    3 cells + ;

linked-list atom-root

: $atom-new ( $ -- A )
    &gt;r &gt;r 0 0 r&gt; r&gt; 4 atom-root chain atom-root cell+ @ ;

: atom-new ( $ -- A )
    $clone $atom-new ;

: atom= ( $ A -- f )
    atom-string@ compare 0= ;

: atom-find' ( $ A -- A )
    begin
       dup 0= if nip nip exit then
       3dup atom= if nip nip exit then
       -&gt;next
    again ;
: atom-find ( $ -- A )
    atom-root @ atom-find' ;

: $atom ( $ -- A )
    2dup atom-find dup if nip nip else drop $atom-new then ;

: atom ( $ -- A )
    2dup atom-find dup if nip nip else drop atom-new then ;

: atom. ( A -- )
    atom-string@ type ;

: atoms. ( -- )
    atom-root @ begin dup while
    dup atom. cr -&gt;next repeat drop ;

: atom&quot; ( -- A )
    [char] &quot; parse
    state @ if postpone sliteral postpone atom
    else atom then ; immediate
: atom{ ( -- A )
    [char] } parse
    state @ if postpone sliteral postpone atom
    else atom then ; immediate

: atom&quot;&quot; ( -- A ) 0 0 atom ;

: atom-append ( A n Ad -- )
    atom-meaning-head 2 swap chain ;
: atom+=$ ( A Ad -- )
    0 swap atom-append ;
: atom+=ref ( A Ad -- )
    1 swap atom-append ;


: ref-parts ( ref -- A ref? )
    cell+ dup cell+ @ swap @ ;
: atom-walk ( fn A -- )
     atom-meaning-head @ begin dup while
         2dup &gt;r &gt;r
         ref-parts if recurse else swap execute then
         r&gt; r&gt;
         -&gt;next
     repeat 2drop ;
: tally-length ( n A -- n )
    atom-length@ + ;
: gather-string ( a A -- a' )
    2dup atom-string@ &gt;r swap r&gt; move tally-length ;
: atom-walk-length ( A -- n )
    0 swap ['] tally-length swap atom-walk ;
: atom-walk-gather ( a A -- )
    swap ['] gather-string swap atom-walk drop ;

: means ( A -- A' )
    dup atom-walk-length dup allocate 0= assert
    swap 2dup &gt;r &gt;r drop
    atom-walk-gather r&gt; r&gt; $atom ;

: atom&gt;&gt;$ ( A d -- d' )
    2dup &gt;r atom-string@ r&gt; swap move swap atom-length@ + ;
: atom+ ( A A -- A )
    swap 2dup atom-length@ swap atom-length@ + dup &gt;r
    allocate 0= assert dup &gt;r
    atom&gt;&gt;$ atom&gt;&gt;$ drop r&gt; r&gt; $atom ;

: atom-ch ( ch -- A )
    1 allocate 0= assert 2dup c! nip 1 atom ;

10 atom-ch constant atom-cr
: atom-cr+ ( A -- A )
    atom-cr atom+ ;


atom&quot; foo&quot; atom&quot; foo&quot; = assert

atom&quot; bar&quot; atom&quot; foo&quot; &lt;&gt; assert

atom&quot; testing&quot; atom&quot; 123&quot; atom+ atom&quot; testing123&quot; = assert

atom&quot; abc&quot; atom&quot; bar&quot; atom+=$
atom&quot; def&quot; atom&quot; bar&quot; atom+=$
atom&quot; 1234&quot; atom&quot; foo&quot; atom+=$
atom&quot; bar&quot; atom&quot; foo&quot; atom+=ref
atom&quot; 5678 9&quot; atom&quot; foo&quot; atom+=$
atom&quot; bar&quot; atom&quot; foo&quot; atom+=ref
atom&quot; foo&quot; means atom&quot; 1234abcdef5678 9abcdef&quot; = assert



: file!-dangle ( A A -- fileid )
    atom-string@ r/w bin create-file 0= assert
    swap over &gt;r atom-string@ r&gt; write-file 0= assert
    dup flush-file 0= assert
;
: file! ( A A -- )
    file!-dangle
    close-file 0= assert
;
: file!-tmp ( A A -- fileid )
    file!-dangle
    dup 0 s&gt;d rot reposition-file 0= assert
;


: escape-ch ( ch -- )
   dup [char] &lt; = if [char] &amp; c, [char] l c, [char] t c,
                     [char] ; c, drop exit then
   dup [char] &gt; = if [char] &amp; c, [char] g c, [char] t c,
                     [char] ; c, drop exit then
   dup [char] &quot; = if [char] &amp; c, [char] q c, [char] u c, [char] o c,
                     [char] t c, [char] ; c, drop exit then
   dup [char] &amp; = if [char] &amp; c, [char] a c, [char] m c, [char] p c,
                     [char] ; c, drop exit then
   c, ;
: escape-each ( A -- )
    atom-string@ 0 ?do dup i + c@ escape-ch loop drop ;
: here! ( a -- )
    here - allot ;
: escape ( A -- A )
    here dup &gt;r swap escape-each here over - atom r&gt; here! ;


: source@ source ( -- a )
    drop &gt;in @ + ;
: source-remaining ( -- n )
   source nip &gt;in @ - ;


: drop| ( -- )

    source@ 1- c@ [char] | = if -1 &gt;in +! then ;
: need-refill? ( -- f)
    source nip &gt;in @ &lt;= ;

: on|? ( -- f )

    need-refill? if false exit then source@ c@ [char] | = ;
: replenish ( -- f )
    need-refill? if refill else true then ;

: ?atom-cr+ ( A -- A )

    on|? 0= if atom-cr+ then ;

: eat| ( -- )

    [char] | parse drop| atom atom+ ?atom-cr+ ;

: parse..| ( -- A )

    atom&quot;&quot; begin replenish 0=

    if exit then eat| on|? until ;

: parse-cr ( -- A )
    source@ source-remaining atom   source nip &gt;in ! ;


variable chunk
: chunk+=$ ( A -- )
    chunk @ if chunk @ atom+=$ else drop then ;
: chunk+=ref ( A -- )
    chunk @ if chunk @ atom+=ref else drop then ;

atom&quot; ~~~DOC&quot; constant main-documentation
variable documentation-chunk
main-documentation documentation-chunk !

: documentation ( -- A )
    documentation-chunk @ ;
: doc! ( back to documentation)
    0 chunk ! ;
: doc+=$ ( A -- )
    documentation atom+=$ ;
: .d{ ( -- )
    postpone atom{ postpone doc+=$ ; immediate

: .d| ( -- )

    parse..| ; immediate

: |.d ( -- )
    postpone literal postpone doc+=$ ; immediate
: .dcr   atom-cr doc+=$ ;
: doc+=ref ( A -- )
    documentation atom+=ref ;
: doc+=use
    ( A -- ) .d{ &lt;b&gt;} doc+=$ .d{ &lt;/b&gt;} ;
: doc+=def ( A -- )
    .d{ &lt;/p&gt;&lt;tt&gt;&lt;b&gt;} doc+=$
    .d{ &lt;/b&gt; +&amp;equiv;&lt;/tt&gt;&lt;div class=&quot;chunk&quot;&gt;&lt;pre&gt;} ;

: feed ( read into current chunk )

    parse..| dup ?atom-cr+ escape doc+=$ atom-cr+ chunk+=$ ;


variable doc-base
atom&quot; index&quot; doc-base !

: |document-base:   parse-cr doc-base ! feed ;

variable title
atom&quot; Untitled&quot; title !

: |title:   parse-cr title ! feed ;

variable author
atom&quot; Anonymous&quot; author !

: |author:   parse-cr author ! feed ;

variable isbn
atom&quot; 9999999999&quot; isbn !

: |isbn:   parse-cr isbn ! feed ;

variable subject
atom&quot; Article&quot; subject !

: |subject:   parse-cr subject ! feed ;

variable doc-date
atom&quot; Unknown&quot; doc-date !

: |date:   parse-cr doc-date ! feed ;

variable description
atom&quot; No description available.&quot; description !

: |description:   parse-cr description ! feed ;



linked-list out-files

: |file: ( add a new output file )
    parse-cr dup 1 out-files chain
    .d{ &lt;tt&gt;&lt;i&gt;} doc+=$ .d{ &lt;/i&gt;&lt;/tt&gt;} feed ;
: file-name@ ( file -- A )
    cell+ @ ;



variable slide-chapter
variable chapter-count
linked-list chapters

: chapter-name ( chp -- A )
    cell+ @ ;
: chapter-text ( chp -- A )
    cell+ @ means ;
: chapter-number ( chp -- n )
    2 cells + @ ;

atom&quot; .html&quot; constant .html
: chapter-filename ( chp -- A )
     chapter-number s&gt;d &lt;# # # # #s #&gt; atom
     doc-base @ atom&quot; _&quot; atom+ swap .html atom+ atom+ ;


: chapter-finish   .d{ &lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;} ;

: raw-chapter ( -- )
     chapter-finish
     parse-cr
     chapter-count @   1 chapter-count +!
     over 2 chapters chain
     dup documentation-chunk ! doc!


.d| &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot;
 &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;

|.d

slide-chapter @ if


.d|
&lt;script type=&quot;text/javascript&quot;&gt;
function SlideCount() {
  var sections = document.getElementsByClassName('section');
  return sections.length;
}

function ShowSlide(index) {
  var sections = document.getElementsByClassName('section');
  for (var i = 0; i &lt; sections.length; i++) {
    sections[i].style.display = ((i == index) ? 'inline' : 'none');
  }
}

var current_slide = 0;

function Load() {
  ShowSlide(0);
  window.onkeydown = function(e) {
    if (e.keyCode == 37) {  // left
      current_slide = Math.max(0, current_slide - 1);
    } else if (e.keyCode == 39) {  // right
      current_slide = Math.min(SlideCount() - 1, current_slide + 1);
    } else if (e.keyCode == 38) {  // up
      current_slide = 0;
    } else if (e.keyCode == 40) {  // down
      current_slide = SlideCount() - 1;
    }
    ShowSlide(current_slide);
  };
}
&lt;/script&gt;

|.d

then


.d|
&lt;style type=&quot;text/css&quot;&gt;
  div.chunk {
    margin: 0em 0.5em;
  }
  pre {
    margin: 0em 0em;
  }

|.d

slide-chapter @ if

.d|
  div.section {
    page-break-before: always;
  }

|.d
then


.d|
&lt;/style&gt;

&lt;title&gt;|.d
    dup doc+=$
    .d{ &lt;/title&gt;&lt;/head&gt;}
    slide-chapter @ if .d{ &lt;body onload=&quot;Load()&quot;&gt;} else .d{ &lt;body&gt;} then
    .d{ &lt;div class=&quot;section&quot;&gt;&lt;h1&gt;}
    doc+=$
    .d{ &lt;/h1&gt;&lt;p&gt;}

    feed
;


: |chapter:   false slide-chapter !  raw-chapter ;

: |slide-chapter:   true slide-chapter !  raw-chapter ;


: |section:   parse-cr .d{ &lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;section&quot;&gt;&lt;h2&gt;} doc+=$
                 .d{ &lt;/h2&gt;&lt;p&gt;} feed ;


: |page   parse-cr .d{ &lt;/p&gt;&lt;p style=&quot;page-break-before:always;&quot;&gt;} feed ;


: |br   parse-cr .d{ &lt;br/&gt;} feed ;


: |$ ( paragraph )
    .d{ &lt;/p&gt;&lt;p&gt;} feed ;


: |\ ( whole line)
    parse-cr atom-cr+ dup chunk+=$ escape doc+=$ feed ;







: |b{   .d{ &lt;b&gt;} feed ;

: |}b   .d{ &lt;/b&gt;} feed ;

: |i{   .d{ &lt;i&gt;} feed ;

: |}i   .d{ &lt;/i&gt;} feed ;

: |u{   .d{ &lt;u&gt;} feed ;

: |}u   .d{ &lt;/u&gt;} feed ;

: |sup{   .d{ &lt;sup&gt;} feed ;

: |}sup   .d{ &lt;/sup&gt;} feed ;

: |sub{   .d{ &lt;sub&gt;} feed ;

: |}sub   .d{ &lt;/sub&gt;} feed ;

: |tt{   .d{ &lt;tt&gt;} feed ;

: |}tt   .d{ &lt;/tt&gt;} feed ;

: |code{   .d{ &lt;div class=&quot;chunk&quot;&gt;&lt;pre&gt;} feed ;

: |}code   .d{ &lt;/pre&gt;&lt;/div&gt;} feed ;


variable bullet-depth
: bullet+   1 bullet-depth +!   bullet-depth @ 1 = if .d{ &lt;/p&gt;} then ;
: bullet-   -1 bullet-depth +!   bullet-depth @ 0 = if .d{ &lt;p&gt;} then ;

: |{-   bullet+ .d{ &lt;ul&gt;&lt;li&gt;} feed ;

: |--   .d{ &lt;/li&gt;&lt;li&gt;} feed ;

: |-}   .d{ &lt;/li&gt;&lt;/ul&gt;} bullet- feed ;



: |TeX .d{ &lt;span&gt;T&lt;sub&gt;&lt;big&gt;E&lt;/big&gt;&lt;/sub&gt;X&lt;/span&gt;} feed ;


: |LaTeX
    .d{ &lt;span&gt;L&lt;sup&gt;&lt;small&gt;A&lt;/small&gt;&lt;/sup&gt;T&lt;sub&gt;&lt;big&gt;E&lt;/big&gt;&lt;/sub&gt;X&lt;/span&gt;}
    feed
;



: |&lt;-| .d{ &amp;larr;} feed ;

: |-&gt;| .d{ &amp;rarr;} feed ;

: |^| .d{ &amp;uarr;} feed ;

: |v| .d{ &amp;darr;} feed ;



: |: ( add to a chunk )
    parse-cr dup chunk ! doc+=def feed ;

: |; ( documentation )
    .d{ &lt;/pre&gt;&lt;/div&gt;&lt;p&gt;} doc! feed ;


: |@ ( use a chunk )
    parse-cr dup chunk+=ref doc+=use .dcr feed ;


: |@@ ( use a chunk in documentation )
    parse-cr means escape doc+=$ feed ;




variable literate-mode
: literate-setup
    depth 0&lt;= if 0 then literate-mode ! ;
literate-setup

literate-mode @ 0 = constant running?
literate-mode @ 1 = constant tangling?
literate-mode @ 2 = constant weaving?

weaving? tangling? or running? or assert



atom&quot; ~~~TOC&quot; constant atom-toc

: toc-filename doc-base @ atom&quot; .html&quot; atom+ ;


: weave-toc-chapter ( chapter -- )
    .d{ &lt;h4&gt;&lt;b&gt;&lt;a href=&quot;}
    dup chapter-filename doc+=$
    .d{ &quot;&gt;}
    chapter-name doc+=$
    .d{ &lt;/a&gt;&lt;/b&gt;&lt;/h4&gt;} .dcr
 ;

: weave-toc
    atom-toc documentation-chunk ! doc!


.d| &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot;
&quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;&lt;title&gt;Table of Contents&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
  &lt;h1&gt;&lt;b&gt;TABLE OF CONTENTS&lt;/b&gt;&lt;/h1&gt;

|.d

    chapters @ begin dup while
    dup weave-toc-chapter -&gt;next repeat drop

    .d{ &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;} .dcr

    documentation means toc-filename file!
;


atom&quot; ~~~NCX&quot; constant atom-ncx

: ncx-filename ( -- A )
    doc-base @ atom&quot; .ncx&quot; atom+ ;


: weave-ncx-chapter ( chapter -- )
   .d{ &lt;navPoint class=&quot;chapter&quot; id=&quot;}
    dup chapter-filename doc+=$
    .d{ &quot; playOrder=&quot;}
    dup chapter-filename doc+=$
    .d{ &quot;&gt;&lt;navLabel&gt;&lt;text&gt;}
    dup chapter-name doc+=$
    .d{ &lt;/text&gt;&lt;/navLabel&gt;&lt;content src=&quot;}
    chapter-filename doc+=$
    .d{ &quot;/&gt;&lt;/navPoint&gt;}
;

: weave-ncx
    atom-ncx documentation-chunk ! doc!


.d| &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE ncx PUBLIC &quot;-//NISO//DTD ncx 2005-1//EN&quot;
&quot;http://www.daisy.org/z3986/2005/ncx-2005-1.dtd&quot;&gt;
&lt;ncx xmlns=&quot;http://www.daisy.org/z3986/2005/ncx/&quot;
 version=&quot;2005-1&quot; xml:lang=&quot;en-US&quot;&gt;
&lt;head&gt;
&lt;meta name=&quot;dtb:uid&quot; content=&quot;BookId&quot;/&gt;
&lt;meta name=&quot;dtb:depth&quot; content=&quot;2&quot;/&gt;
&lt;meta name=&quot;dtb:totalPageCount&quot; content=&quot;0&quot;/&gt;
&lt;meta name=&quot;dtb:maxPageNumber&quot; content=&quot;0&quot;/&gt;
&lt;/head&gt;


|.d
.d{ &lt;docTitle&gt;&lt;text&gt;} title @ doc+=$

.d| &lt;/text&gt;&lt;/docTitle&gt;
&lt;docAuthor&gt;&lt;text&gt;me&lt;/text&gt;&lt;/docAuthor&gt;

  &lt;navMap&gt;
    &lt;navPoint class=&quot;toc&quot; id=&quot;toc&quot; playOrder=&quot;1&quot;&gt;
      &lt;navLabel&gt;
        &lt;text&gt;Table of Contents&lt;/text&gt;
      &lt;/navLabel&gt;


     &lt;content src=&quot;|.d toc-filename doc+=$ .d| &quot;/&gt;
     &lt;/navPoint&gt;

|.d

    chapters @ begin dup while
    dup weave-ncx-chapter -&gt;next repeat drop

    .d{ &lt;/navMap&gt;&lt;/ncx&gt;}
    documentation means ncx-filename file!
;


: cover-filename doc-base @ atom&quot; _cover.bmp&quot; atom+ ;


variable image-width
variable image-height
variable image-data

: image-data-size ( -- n )
    image-width @ image-height @ * 4 * ;

: image-pick-size ( w h -- )
    image-height ! image-width ! ;
: image-free-old
    image-data @ dup if free 0= assert else drop then ;
: image-allocate
    image-data-size allocate 0= assert image-data ! ;
: image-clear
    image-data @ image-data-size 0 fill ;
: image-setup ( w h -- )
    image-pick-size image-free-old image-allocate image-clear ;


variable red
variable green
variable blue

: rgb ( r g b -- ) blue ! green ! red ! ;
: f&gt;primary ( f -- n ) 255e f* f&gt;s 0 max 255 min ;
: rgbf ( rf gf bf -- ) f&gt;primary f&gt;primary f&gt;primary rgb ;

: black ( -- ) 0 0 0 rgb ;
: white ( -- ) 255 255 255 rgb ;

: gray ( n -- ) dup dup rgb ;

: image-xy ( x y -- a )
    image-width @ * + 4 *
    image-data @ + ;
: plot ( x y -- )
    image-xy
    red @ over c!
    green @ over 1+ c!
    blue @ over 2 + c!
    0 swap 3 + c! ;


variable bmp-file

: bmp-begin ( A -- )
    atom-string@ w/o bin create-file 0= assert bmp-file ! ;
: bmp-end ( -- )
    bmp-file @ close-file 0= assert ;

: bmp-write ( $ -- )
    bmp-file @ write-file 0= assert ;

: bmp-byte ( b -- ) here c! here 1 bmp-write ;
: bmp-word ( w -- ) dup 255 and bmp-byte 8 rshift 255 and bmp-byte ;
: bmp-dword ( d -- ) dup 65535 and bmp-word 16 rshift 65535 and bmp-word ;

3 2 * 2 4 * + constant bmp-header-size
10 4 * constant dib-header-size

: bmp-save ( A -- )
  bmp-begin
  \ BMP header
  s&quot; BM&quot; bmp-write
  bmp-header-size
  dib-header-size +
  image-data-size + bmp-dword \ size of bmp file in bytes
  0 bmp-word \ unused
  0 bmp-word \ unused
  bmp-header-size
  dib-header-size + bmp-dword \ offset to start of bitmap image data

  \ DIB header
  dib-header-size bmp-dword \ size of header in bytes
  image-width @ bmp-dword \ width
  image-height @ bmp-dword \ height
  1 bmp-word \ color planes
  32 bmp-word \ bits per pixel
  0 bmp-dword \ BI_RGB (uncompressed)
  image-data-size bmp-dword \ pixel data size
  0 bmp-dword \ horizontal pixels per meter
  0 bmp-dword \ vertical pixels per meter
  0 bmp-dword \ colors in color palette
  0 bmp-dword \ important colors in palette

  \ Image data
  image-data @ image-data-size bmp-write
  bmp-end
;


fvariable xx
fvariable yy
: x ( -- f ) xx f@ ;
: y ( -- f ) yy f@ ;
variable xn
variable yn

fvariable aspect
1e aspect f!

: haiku ( f -- )
  image-height @ 0 do
    i yn !
    i s&gt;f 0.5e f+ image-width @ s&gt;f aspect f@ f/ f/ yy f!
    image-width @ 0 do
      i xn !
      i s&gt;f 0.5e f+ image-width @ s&gt;f f/ xx f!
      dup execute
      rgbf i j plot
    loop
  loop
  drop
;

0.0722e fconstant red-luminance
0.7152e fconstant green-luminance
0.2126e fconstant blue-luminance
: luminance ( rf gf bf -- f )
    blue-luminance f* fswap
    green-luminance f* f+ fswap
    red-luminance f* f+ ;

create dither-table
 1 , 49 , 13 , 61 ,  4 , 52 , 16 , 64 ,
33 , 17 , 45 , 29 , 36 , 20 , 48 , 32 ,
 9 , 57 ,  5 , 53 , 12 , 60 ,  8 , 56 ,
41 , 25 , 37 , 21 , 44 , 28 , 40 , 24 ,
 3 , 51 , 15 , 63 ,  2 , 50 , 14 , 62 ,
35 , 19 , 47 , 31 , 34 , 18 , 46 , 30 ,
11 , 59 ,  7 , 55 , 10 , 58 ,  6 , 54 ,
43 , 27 , 39 , 23 , 42 , 26 , 38 , 22 ,

: dither-map ( x y -- f )
  8 mod 8 * swap 8 mod + cells dither-table + @ s&gt;f 65e f/ 0.5e f- ;

: dither ( -- f )
  xn @ yn @ dither-map 7e f/ ;

: 3dither-scale ( f -- f ) 7e f/ ;
: 3dither ( rgb -- rgb' )
  dither blue-luminance f/ 3dither-scale f+ frot
  dither green-luminance f/ 3dither-scale f+ frot
  dither red-luminance f/ 3dither-scale f+ frot ;


fvariable gradient-scale
: 3fg* ( f f f -- f f f )
   gradient-scale f@ f* frot
   gradient-scale f@ f* frot
   gradient-scale f@ f* frot
;
: gradient-invert
  1e gradient-scale f@ f- gradient-scale f! ;

: gradient1
   1e x f- 0.3e f* y f+ 0.5e f+ 10e f**
   0e fmax 1e fmin
   gradient-scale f! ;

fvariable 3f+temp
: 3f+ ( xyz abc -- x+a y+b z+c )
  fswap 3f+temp f! frot f+ ( x y a z+c )
  frot 3f+temp f@ f+ ( x a z+c y+b )
  3f+temp f! frot frot f+ ( z+c x+a )
  3f+temp f@ frot ( x+a y+b z+c )
;


: 4spire
  x x 23e f* fsin 2e f/ y fmax f/ fsin
  y x 23e f* fsin 2e f/ y fmax f/ fsin
  fover fover f/ fsin
;


: scales-x' x 0.3e f- ;
: scales-y' y 0.1e f+ ;
: scales
  scales-x' scales-y' f* 40e f* fsin
  1e scales-x' f- scales-y' f* 30e f* fsin f*
  scales-x' 1e scales-y' f- f* 20e f* fsin f*
  fdup scales-x' f/ fsin
  fdup scales-y' f/ fcos 1e x f- 1e y f- f+ f*
;

: scales-4spire
  scales gradient1 3fg*
  4spire gradient1 gradient-invert 3fg* 3f+
;

: scales-4spire-dithered
  scales-4spire 3dither
;

: scales-4spire-gray
  scales-4spire luminance dither f+ fdup fdup
;

: weave-cover
  600 800 image-setup
  ['] scales-4spire-dithered haiku
  cover-filename bmp-save
;


atom&quot; ~~~OPF&quot; constant atom-opf

: opf-filename ( -- A )
    doc-base @ atom&quot; .opf&quot; atom+ ;


: opf-chapter ( A -- )
    .d{ &lt;item id=&quot;}
    dup doc+=$
    .d{ &quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;}
    doc+=$
    .d{ &quot;&gt;&lt;/item&gt;} .dcr
;


: opf-chapter' ( A -- )
    .d{ &lt;itemref idref=&quot;} doc+=$ .d{ &quot;/&gt;} .dcr ;

: weave-opf
    atom-opf documentation-chunk ! doc!


.d| &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;package xmlns=&quot;http://www.idpf.org/2007/opf&quot; version=&quot;2.0&quot;
unique-identifier=&quot;BookId&quot;&gt;
&lt;metadata xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot;
xmlns:opf=&quot;http://www.idpf.org/2007/opf&quot;&gt;

|.d

    .d{ &lt;dc:title&gt;} title @ doc+=$ .d{ &lt;/dc:title&gt;} .dcr
    .d{ &lt;dc:language&gt;en-us&lt;/dc:language&gt;} .dcr
    .d{ &lt;meta name=&quot;cover&quot; content=&quot;My_Cover&quot;/&gt; } .dcr
    .d{ &lt;dc:identifier id=&quot;BookId&quot; opf:scheme=&quot;ISBN&quot;&gt;}
    isbn @ doc+=$ .d{ &lt;/dc:identifier&gt;} .dcr
    .d{ &lt;dc:creator&gt;} author @ doc+=$ .d{ &lt;/dc:creator&gt;} .dcr
    .d{ &lt;dc:publisher&gt;} author @ doc+=$ .d{ &lt;/dc:publisher&gt;} .dcr
    .d{ &lt;dc:subject&gt;} subject @ doc+=$ .d{ &lt;/dc:subject&gt;} .dcr
    .d{ &lt;dc:date&gt;} doc-date @ doc+=$ .d{ &lt;/dc:date&gt;} .dcr
    .d{ &lt;dc:description&gt;} description @ doc+=$ .d{ &lt;/dc:description&gt;} .dcr

.d|
&lt;/metadata&gt;

&lt;manifest&gt;
   &lt;item id=&quot;My_Table_of_Contents&quot; media-type=&quot;application/x-dtbncx+xml&quot;

   href=&quot;|.d ncx-filename doc+=$ .d| &quot;/&gt;

  &lt;item id=&quot;toc&quot; media-type=&quot;application/xhtml+xml&quot; href=&quot;|.d
    toc-filename doc+=$ .d{ &quot;&gt;&lt;/item&gt;}
    chapters @ begin dup while
        dup chapter-filename opf-chapter -&gt;next
    repeat drop
    .d{ &lt;item id=&quot;My_Cover&quot; media-type=&quot;image/gif&quot;} .dcr
    .d{  href=&quot;} cover-filename doc+=$ .d{ &quot;/&gt;} .dcr
    .d{ &lt;/manifest&gt;}

    .d{ &lt;spine toc=&quot;My_Table_of_Contents&quot;&gt;&lt;itemref idref=&quot;toc&quot;/&gt;}
    chapters @ begin dup while
        dup chapter-filename opf-chapter' -&gt;next
    repeat drop
   .d{ &lt;/spine&gt;}


.d|
&lt;guide&gt;
  &lt;reference type=&quot;toc&quot; title=&quot;Table of Contents&quot;

   href=&quot;|.d toc-filename doc+=$ .d| &quot;&gt;&lt;/reference&gt;
&lt;/guide&gt;
&lt;/package&gt;

|.d

   documentation means opf-filename file!
;


: weave-chapter ( chapter -- )
    dup chapter-text swap chapter-filename file! ;
: weave-chapters
    chapters @ begin dup while
    dup weave-chapter -&gt;next repeat drop ;

: weave ( -- )
    weave-opf
    weave-ncx
    weave-cover
    weave-toc
    weave-chapters
;


: tangle-file ( file -- )
    file-name@ dup means swap file! ;

: tangle
    out-files @ begin dup while
    dup tangle-file -&gt;next repeat drop ;


: run-filename ( -- A )
    doc-base @ atom&quot; _running.tmp&quot; atom+ ;

: run-cleanup
    run-filename atom-string@ delete-file drop ;

: bye   run-cleanup bye ;

: run
    atom&quot; *&quot; means
    run-filename file!-tmp
    forth-wordlist 1 set-order
    forth-wordlist set-current
    include-file
    run-cleanup
;



: |. ( exit literate mode )
     chapter-finish
     weaving? if weave bye then
     tangling? if tangle bye then
     running? if run then ;



</pre></div>

</p></div></body></html>